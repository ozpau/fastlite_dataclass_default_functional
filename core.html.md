# core


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

``` python
from fastlite import *
```

``` python
db = database(':memory:')
```

``` python
db.q("""
CREATE TABLE IF NOT EXISTS migrations (
    id INTEGER PRIMARY KEY, name TEXT, inserted_at DATETIME DEFAULT CURRENT_TIMESTAMP NOT NULL
);
""")
```

    []

``` python
def list_records(): return db.q("SELECT * FROM migrations")
list_records()
```

    []

``` python
migrations = db.t.migrations
Migration = migrations.dataclass()
```

Creating `Migration` with dataclass copies default value that is an SQL
function:

``` python
m = Migration(name='setup_db')
m
```

    Migrations(id=UNSET, name='setup_db', inserted_at='CURRENT_TIMESTAMP')

``` python
migrations.insert(m)
```

    Migrations(id=1, name='setup_db', inserted_at='CURRENT_TIMESTAMP')

Inserting this record doesn’t execure the SQL function as expected:

``` python
list_records()
```

    [{'id': 1, 'name': 'setup_db', 'inserted_at': 'CURRENT_TIMESTAMP'}]

Now let’s do a similar insert using raw SQL:db.q(“SELECT \* FROM
migrations”)

``` python
db.q("INSERT INTO migrations (name) VALUES('create_users')")
```

    []

``` python
list_records()
```

    [{'id': 1, 'name': 'setup_db', 'inserted_at': 'CURRENT_TIMESTAMP'},
     {'id': 2, 'name': 'create_users', 'inserted_at': '2025-03-08 15:23:30'}]

As you can see, the SQL function got called as it should.
